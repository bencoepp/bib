package postgres

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// ConfigGenerator generates PostgreSQL configuration files.
type ConfigGenerator struct {
	nodeID            string
	dataDir           string
	configDir         string
	certDir           string
	port              int
	maxConnections    int
	sharedBuffers     string
	useUnixSocket     bool
	socketDir         string
	requireClientCert bool
	dockerSubnet      string
	dockerNetwork     string
}

// ConfigGeneratorOptions holds options for the config generator.
type ConfigGeneratorOptions struct {
	NodeID            string
	DataDir           string
	ConfigDir         string
	CertDir           string
	Port              int
	MaxConnections    int
	SharedBuffers     string
	UseUnixSocket     bool
	SocketDir         string
	RequireClientCert bool
	DockerSubnet      string
	DockerNetwork     string
}

// NewConfigGenerator creates a new PostgreSQL config generator.
func NewConfigGenerator(opts ConfigGeneratorOptions) *ConfigGenerator {
	if opts.Port == 0 {
		opts.Port = 5432
	}
	if opts.MaxConnections == 0 {
		opts.MaxConnections = 100
	}
	if opts.SharedBuffers == "" {
		opts.SharedBuffers = "256MB"
	}

	return &ConfigGenerator{
		nodeID:            opts.NodeID,
		dataDir:           opts.DataDir,
		configDir:         opts.ConfigDir,
		certDir:           opts.CertDir,
		port:              opts.Port,
		maxConnections:    opts.MaxConnections,
		sharedBuffers:     opts.SharedBuffers,
		useUnixSocket:     opts.UseUnixSocket,
		socketDir:         opts.SocketDir,
		requireClientCert: opts.RequireClientCert,
		dockerSubnet:      opts.DockerSubnet,
		dockerNetwork:     opts.DockerNetwork,
	}
}

// GeneratePostgresConf generates the postgresql.conf content.
func (g *ConfigGenerator) GeneratePostgresConf() string {
	var cfg strings.Builder

	cfg.WriteString("# PostgreSQL Configuration\n")
	cfg.WriteString("# Generated by bibd - DO NOT EDIT MANUALLY\n")
	cfg.WriteString(fmt.Sprintf("# Node ID: %s\n\n", g.nodeID))

	// Connection Settings
	cfg.WriteString("# === Connection Settings ===\n")
	if g.useUnixSocket {
		cfg.WriteString("listen_addresses = ''\n")
		if g.socketDir != "" {
			cfg.WriteString(fmt.Sprintf("unix_socket_directories = '%s'\n", g.socketDir))
		}
	} else {
		// Inside container, listen on all interfaces (external access controlled by port binding)
		cfg.WriteString("listen_addresses = '*'\n")
	}
	cfg.WriteString(fmt.Sprintf("port = %d\n", g.port))
	cfg.WriteString(fmt.Sprintf("max_connections = %d\n", g.maxConnections))
	cfg.WriteString("\n")

	// SSL/TLS Configuration
	cfg.WriteString("# === SSL/TLS Configuration ===\n")
	cfg.WriteString("ssl = on\n")
	cfg.WriteString("ssl_cert_file = '/var/lib/postgresql/certs/server.crt'\n")
	cfg.WriteString("ssl_key_file = '/var/lib/postgresql/certs/server.key'\n")
	cfg.WriteString("ssl_ca_file = '/var/lib/postgresql/certs/ca.crt'\n")
	cfg.WriteString("ssl_min_protocol_version = 'TLSv1.3'\n")
	cfg.WriteString("ssl_prefer_server_ciphers = on\n")
	cfg.WriteString("ssl_ciphers = 'HIGH:!aNULL:!MD5:!3DES:!RC4'\n")
	cfg.WriteString("\n")

	// Authentication
	cfg.WriteString("# === Authentication ===\n")
	cfg.WriteString("password_encryption = scram-sha-256\n")
	cfg.WriteString("db_user_namespace = off\n")
	cfg.WriteString("\n")

	// Audit Logging
	cfg.WriteString("# === Audit Logging ===\n")
	cfg.WriteString("log_destination = 'stderr'\n")
	cfg.WriteString("logging_collector = on\n")
	cfg.WriteString("log_directory = '/var/log/postgresql'\n")
	cfg.WriteString("log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'\n")
	cfg.WriteString("log_rotation_age = 1d\n")
	cfg.WriteString("log_rotation_size = 100MB\n")
	cfg.WriteString("log_truncate_on_rotation = off\n")
	cfg.WriteString("log_statement = 'all'\n")
	cfg.WriteString("log_connections = on\n")
	cfg.WriteString("log_disconnections = on\n")
	cfg.WriteString("log_duration = on\n")
	cfg.WriteString("log_hostname = off\n")
	cfg.WriteString("log_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h '\n")
	cfg.WriteString("log_timezone = 'UTC'\n")
	cfg.WriteString("\n")

	// Security Restrictions
	cfg.WriteString("# === Security Restrictions ===\n")
	cfg.WriteString("row_security = on\n")
	cfg.WriteString("session_replication_role = 'origin'\n")
	cfg.WriteString("\n")

	// Performance Settings
	cfg.WriteString("# === Performance ===\n")
	cfg.WriteString(fmt.Sprintf("shared_buffers = '%s'\n", g.sharedBuffers))
	cfg.WriteString("effective_cache_size = '1GB'\n")
	cfg.WriteString("maintenance_work_mem = '64MB'\n")
	cfg.WriteString("work_mem = '16MB'\n")
	cfg.WriteString("wal_buffers = '16MB'\n")
	cfg.WriteString("\n")

	// Extensions
	cfg.WriteString("# === Extensions ===\n")
	cfg.WriteString("shared_preload_libraries = 'pg_stat_statements'\n")
	cfg.WriteString("pg_stat_statements.track = 'all'\n")
	cfg.WriteString("\n")

	// Data Integrity
	cfg.WriteString("# === Data Integrity ===\n")
	cfg.WriteString("fsync = on\n")
	cfg.WriteString("synchronous_commit = on\n")
	cfg.WriteString("full_page_writes = on\n")
	cfg.WriteString("checkpoint_completion_target = 0.9\n")
	cfg.WriteString("\n")

	return cfg.String()
}

// GeneratePgHbaConf generates the pg_hba.conf content.
func (g *ConfigGenerator) GeneratePgHbaConf() string {
	var cfg strings.Builder

	cfg.WriteString("# PostgreSQL Host-Based Authentication\n")
	cfg.WriteString("# Generated by bibd - DO NOT EDIT MANUALLY\n")
	cfg.WriteString(fmt.Sprintf("# Node ID: %s\n\n", g.nodeID))
	cfg.WriteString("# TYPE  DATABASE        USER            ADDRESS                 METHOD\n\n")

	// Local connections (Unix socket) - SCRAM only
	cfg.WriteString("# Local connections via Unix socket\n")
	cfg.WriteString("local   all             all                                     scram-sha-256\n")
	cfg.WriteString("\n")

	// SSL connections
	cfg.WriteString("# SSL connections\n")
	if g.requireClientCert {
		cfg.WriteString("# Client certificate verification required\n")
		cfg.WriteString("hostssl all             all             127.0.0.1/32            scram-sha-256 clientcert=verify-full\n")
		cfg.WriteString("hostssl all             all             ::1/128                 scram-sha-256 clientcert=verify-full\n")
	} else {
		cfg.WriteString("# SSL required, client certificate optional\n")
		cfg.WriteString("hostssl all             all             127.0.0.1/32            scram-sha-256\n")
		cfg.WriteString("hostssl all             all             ::1/128                 scram-sha-256\n")
	}
	cfg.WriteString("\n")

	// Docker internal network (if configured)
	if g.dockerSubnet != "" {
		cfg.WriteString("# Docker internal network\n")
		if g.requireClientCert {
			cfg.WriteString(fmt.Sprintf("hostssl all             all             %s            scram-sha-256 clientcert=verify-full\n", g.dockerSubnet))
		} else {
			cfg.WriteString(fmt.Sprintf("hostssl all             all             %s            scram-sha-256\n", g.dockerSubnet))
		}
		cfg.WriteString("\n")
	}

	// Default: allow from container's own network for inter-container communication
	cfg.WriteString("# Allow connections from Docker network (internal only)\n")
	if g.requireClientCert {
		cfg.WriteString("hostssl all             all             172.16.0.0/12           scram-sha-256 clientcert=verify-full\n")
		cfg.WriteString("hostssl all             all             10.0.0.0/8              scram-sha-256 clientcert=verify-full\n")
	} else {
		cfg.WriteString("hostssl all             all             172.16.0.0/12           scram-sha-256\n")
		cfg.WriteString("hostssl all             all             10.0.0.0/8              scram-sha-256\n")
	}
	cfg.WriteString("\n")

	// Reject everything else
	cfg.WriteString("# Reject all other connections\n")
	cfg.WriteString("host    all             all             0.0.0.0/0               reject\n")
	cfg.WriteString("host    all             all             ::/0                    reject\n")

	return cfg.String()
}

// WriteConfigs writes all configuration files to the config directory.
func (g *ConfigGenerator) WriteConfigs() error {
	// Create config directory if it doesn't exist
	if err := os.MkdirAll(g.configDir, 0700); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Write postgresql.conf
	postgresConfPath := filepath.Join(g.configDir, "postgresql.conf")
	if err := os.WriteFile(postgresConfPath, []byte(g.GeneratePostgresConf()), 0600); err != nil {
		return fmt.Errorf("failed to write postgresql.conf: %w", err)
	}

	// Write pg_hba.conf
	pgHbaConfPath := filepath.Join(g.configDir, "pg_hba.conf")
	if err := os.WriteFile(pgHbaConfPath, []byte(g.GeneratePgHbaConf()), 0600); err != nil {
		return fmt.Errorf("failed to write pg_hba.conf: %w", err)
	}

	return nil
}

// InitScriptData holds data for init script templates.
type InitScriptData struct {
	NodeID            string
	SuperuserPassword string
	AdminPassword     string
	ScrapePassword    string
	QueryPassword     string
	TransformPassword string
	AuditPassword     string
	ReadonlyPassword  string
}

// GenerateInitScripts creates the init scripts directory with all SQL files.
func (g *ConfigGenerator) GenerateInitScripts(data InitScriptData) error {
	initDir := filepath.Join(g.configDir, "initdb.d")
	if err := os.MkdirAll(initDir, 0700); err != nil {
		return fmt.Errorf("failed to create initdb.d directory: %w", err)
	}

	scripts := map[string]string{
		"00-extensions.sql": extensionsSQL,
		"01-roles.sql":      g.generateRolesSQL(data),
		"02-schema.sql":     schemaSQL,
		"03-audit.sql":      auditSQL,
		"04-hardening.sql":  hardeningSQL,
	}

	for filename, content := range scripts {
		path := filepath.Join(initDir, filename)
		if err := os.WriteFile(path, []byte(content), 0600); err != nil {
			return fmt.Errorf("failed to write %s: %w", filename, err)
		}
	}

	return nil
}

// generateRolesSQL generates the roles creation SQL with passwords.
func (g *ConfigGenerator) generateRolesSQL(data InitScriptData) string {
	tmpl := `-- PostgreSQL Role Creation
-- Generated by bibd - DO NOT EDIT MANUALLY
-- Node ID: {{.NodeID}}

-- Create roles if they don't exist
DO $$
BEGIN
    -- Admin role (can assume all other roles)
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'bibd_admin') THEN
        CREATE ROLE bibd_admin WITH LOGIN PASSWORD '{{.AdminPassword}}';
    ELSE
        ALTER ROLE bibd_admin WITH PASSWORD '{{.AdminPassword}}';
    END IF;

    -- Scrape role (for data ingestion)
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'bibd_scrape') THEN
        CREATE ROLE bibd_scrape WITH LOGIN PASSWORD '{{.ScrapePassword}}' NOINHERIT NOCREATEDB NOCREATEROLE;
    ELSE
        ALTER ROLE bibd_scrape WITH PASSWORD '{{.ScrapePassword}}';
    END IF;

    -- Query role (read-only access)
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'bibd_query') THEN
        CREATE ROLE bibd_query WITH LOGIN PASSWORD '{{.QueryPassword}}' NOINHERIT NOCREATEDB NOCREATEROLE;
    ELSE
        ALTER ROLE bibd_query WITH PASSWORD '{{.QueryPassword}}';
    END IF;

    -- Transform role (read/write for transformations)
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'bibd_transform') THEN
        CREATE ROLE bibd_transform WITH LOGIN PASSWORD '{{.TransformPassword}}' NOINHERIT NOCREATEDB NOCREATEROLE;
    ELSE
        ALTER ROLE bibd_transform WITH PASSWORD '{{.TransformPassword}}';
    END IF;

    -- Audit role (audit log access)
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'bibd_audit') THEN
        CREATE ROLE bibd_audit WITH LOGIN PASSWORD '{{.AuditPassword}}' NOINHERIT NOCREATEDB NOCREATEROLE;
    ELSE
        ALTER ROLE bibd_audit WITH PASSWORD '{{.AuditPassword}}';
    END IF;

    -- Readonly role (for cache/proxy)
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = 'bibd_readonly') THEN
        CREATE ROLE bibd_readonly WITH LOGIN PASSWORD '{{.ReadonlyPassword}}' NOINHERIT NOCREATEDB NOCREATEROLE;
    ELSE
        ALTER ROLE bibd_readonly WITH PASSWORD '{{.ReadonlyPassword}}';
    END IF;
END
$$;

-- Grant role membership to admin (for SET ROLE)
GRANT bibd_scrape TO bibd_admin;
GRANT bibd_query TO bibd_admin;
GRANT bibd_transform TO bibd_admin;
GRANT bibd_audit TO bibd_admin;
GRANT bibd_readonly TO bibd_admin;

-- Set connection limits
ALTER ROLE bibd_scrape CONNECTION LIMIT 10;
ALTER ROLE bibd_query CONNECTION LIMIT 20;
ALTER ROLE bibd_transform CONNECTION LIMIT 10;
ALTER ROLE bibd_audit CONNECTION LIMIT 5;
ALTER ROLE bibd_readonly CONNECTION LIMIT 20;
ALTER ROLE bibd_admin CONNECTION LIMIT 50;
`

	t := template.Must(template.New("roles").Parse(tmpl))
	var buf strings.Builder
	t.Execute(&buf, data)
	return buf.String()
}

const extensionsSQL = `-- PostgreSQL Extensions
-- Generated by bibd - DO NOT EDIT MANUALLY

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
`

const schemaSQL = `-- PostgreSQL Schema
-- Generated by bibd - DO NOT EDIT MANUALLY
-- Note: Actual schema is managed by migrations (Phase 2.6)

-- Placeholder for schema - will be populated by migration system
`

const auditSQL = `-- PostgreSQL Audit Configuration
-- Generated by bibd - DO NOT EDIT MANUALLY

-- Create audit log table
CREATE TABLE IF NOT EXISTS audit_log (
    id                   BIGSERIAL PRIMARY KEY,
    timestamp            TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    node_id              TEXT NOT NULL,
    job_id               UUID,
    operation_id         UUID NOT NULL,
    role_used            TEXT NOT NULL,
    action               TEXT NOT NULL,
    table_name           TEXT,
    query                TEXT,
    query_hash           TEXT,
    rows_affected        INTEGER,
    duration_ms          INTEGER,
    source_component     TEXT,
    actor                TEXT,
    metadata             JSONB,
    prev_hash            TEXT,
    entry_hash           TEXT NOT NULL,
    flag_break_glass     BOOLEAN NOT NULL DEFAULT FALSE,
    flag_rate_limited    BOOLEAN NOT NULL DEFAULT FALSE,
    flag_suspicious      BOOLEAN NOT NULL DEFAULT FALSE,
    flag_alert_triggered BOOLEAN NOT NULL DEFAULT FALSE
);

-- Create indexes for common queries
CREATE INDEX IF NOT EXISTS idx_audit_log_timestamp ON audit_log(timestamp);
CREATE INDEX IF NOT EXISTS idx_audit_log_node_id ON audit_log(node_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_job_id ON audit_log(job_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_operation_id ON audit_log(operation_id);
CREATE INDEX IF NOT EXISTS idx_audit_log_action ON audit_log(action);
CREATE INDEX IF NOT EXISTS idx_audit_log_actor ON audit_log(actor);
CREATE INDEX IF NOT EXISTS idx_audit_log_suspicious ON audit_log(flag_suspicious) WHERE flag_suspicious = TRUE;
CREATE INDEX IF NOT EXISTS idx_audit_log_query_hash ON audit_log(query_hash);

-- Append-only trigger
CREATE OR REPLACE FUNCTION audit_no_modify()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Audit log is append-only: modifications are not permitted';
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS audit_immutable ON audit_log;
CREATE TRIGGER audit_immutable
    BEFORE UPDATE OR DELETE ON audit_log
    FOR EACH ROW
    EXECUTE FUNCTION audit_no_modify();

-- Grant permissions
GRANT SELECT, INSERT ON audit_log TO bibd_audit;
GRANT SELECT ON audit_log TO bibd_readonly;
GRANT USAGE ON SEQUENCE audit_log_id_seq TO bibd_audit;
`

const hardeningSQL = `-- PostgreSQL Hardening
-- Generated by bibd - DO NOT EDIT MANUALLY

-- Revoke public schema access from PUBLIC
REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM PUBLIC;
REVOKE ALL ON ALL SEQUENCES IN SCHEMA public FROM PUBLIC;
REVOKE ALL ON ALL FUNCTIONS IN SCHEMA public FROM PUBLIC;

-- Grant schema access to admin only
GRANT ALL ON SCHEMA public TO bibd_admin;

-- Revoke default privileges
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON TABLES FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON SEQUENCES FROM PUBLIC;
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM PUBLIC;

-- Grant default privileges to admin
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO bibd_admin;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO bibd_admin;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON FUNCTIONS TO bibd_admin;

-- Ensure roles cannot elevate privileges
ALTER ROLE bibd_scrape NOINHERIT NOCREATEDB NOCREATEROLE NOREPLICATION NOBYPASSRLS;
ALTER ROLE bibd_query NOINHERIT NOCREATEDB NOCREATEROLE NOREPLICATION NOBYPASSRLS;
ALTER ROLE bibd_transform NOINHERIT NOCREATEDB NOCREATEROLE NOREPLICATION NOBYPASSRLS;
ALTER ROLE bibd_audit NOINHERIT NOCREATEDB NOCREATEROLE NOREPLICATION NOBYPASSRLS;
ALTER ROLE bibd_readonly NOINHERIT NOCREATEDB NOCREATEROLE NOREPLICATION NOBYPASSRLS;

-- Disable statement timeout for long-running queries (will be set per-session)
ALTER ROLE bibd_admin SET statement_timeout = '0';
ALTER ROLE bibd_scrape SET statement_timeout = '5min';
ALTER ROLE bibd_query SET statement_timeout = '2min';
ALTER ROLE bibd_transform SET statement_timeout = '10min';
ALTER ROLE bibd_audit SET statement_timeout = '1min';
ALTER ROLE bibd_readonly SET statement_timeout = '1min';

-- Set application name for audit logging
ALTER ROLE bibd_admin SET application_name = 'bibd-admin';
ALTER ROLE bibd_scrape SET application_name = 'bibd-scrape';
ALTER ROLE bibd_query SET application_name = 'bibd-query';
ALTER ROLE bibd_transform SET application_name = 'bibd-transform';
ALTER ROLE bibd_audit SET application_name = 'bibd-audit';
ALTER ROLE bibd_readonly SET application_name = 'bibd-readonly';
`
