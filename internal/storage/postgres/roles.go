package postgres

import (
	"context"
	"fmt"
	"strings"

	"bib/internal/storage"
	"bib/internal/storage/postgres/credentials"

	"github.com/jackc/pgx/v5"
)

// RoleManager handles PostgreSQL role creation and management.
type RoleManager struct {
	nodeID string
}

// NewRoleManager creates a new role manager.
func NewRoleManager(nodeID string) *RoleManager {
	return &RoleManager{nodeID: nodeID}
}

// RoleDefinition defines a PostgreSQL role with its permissions.
type RoleDefinition struct {
	Name        storage.DBRole
	Description string
	Tables      map[string][]string // table -> permissions
	CanLogin    bool
	Inherit     bool
	CreateDB    bool
	CreateRole  bool
}

// GetRoleDefinitions returns all role definitions for bibd.
func GetRoleDefinitions() []RoleDefinition {
	return []RoleDefinition{
		{
			Name:        storage.RoleScrape,
			Description: "Role for scraping/ingestion jobs - can insert data",
			Tables: map[string][]string{
				"datasets": {"INSERT"},
				"chunks":   {"INSERT"},
				"topics":   {"SELECT"},
			},
			CanLogin: true,
			Inherit:  false,
		},
		{
			Name:        storage.RoleQuery,
			Description: "Role for query operations - read-only access",
			Tables: map[string][]string{
				"datasets": {"SELECT"},
				"chunks":   {"SELECT"},
				"topics":   {"SELECT"},
				"jobs":     {"SELECT"},
				"nodes":    {"SELECT"},
			},
			CanLogin: true,
			Inherit:  false,
		},
		{
			Name:        storage.RoleTransform,
			Description: "Role for transformation jobs - can read and write data",
			Tables: map[string][]string{
				"datasets": {"SELECT", "INSERT", "UPDATE"},
				"chunks":   {"SELECT", "INSERT", "UPDATE"},
				"topics":   {"SELECT"},
			},
			CanLogin: true,
			Inherit:  false,
		},
		{
			Name:        storage.RoleAudit,
			Description: "Role for audit logging - can read and write audit log",
			Tables: map[string][]string{
				"audit_log": {"SELECT", "INSERT"},
			},
			CanLogin: true,
			Inherit:  false,
		},
		{
			Name:        storage.RoleReadOnly,
			Description: "Role for read-only cache/proxy operations",
			Tables: map[string][]string{
				"datasets":  {"SELECT"},
				"chunks":    {"SELECT"},
				"topics":    {"SELECT"},
				"jobs":      {"SELECT"},
				"nodes":     {"SELECT"},
				"audit_log": {"SELECT"},
			},
			CanLogin: true,
			Inherit:  false,
		},
		{
			Name:        storage.RoleAdmin,
			Description: "Admin role - can assume all other roles",
			Tables:      map[string][]string{}, // Gets all via role membership
			CanLogin:    true,
			Inherit:     true,
		},
	}
}

// GenerateCreateRolesSQL generates SQL to create all roles.
func (rm *RoleManager) GenerateCreateRolesSQL(creds *credentials.Credentials) string {
	var sb strings.Builder

	sb.WriteString("-- bibd PostgreSQL Role Creation\n")
	sb.WriteString("-- Generated by bibd - DO NOT EDIT MANUALLY\n\n")

	// Create superuser (if not exists)
	sb.WriteString("-- Superuser (internal use only)\n")
	sb.WriteString(fmt.Sprintf(`DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '%s') THEN
        CREATE ROLE %s WITH LOGIN SUPERUSER PASSWORD '%s';
    END IF;
END
$$;

`, creds.Superuser.Username, creds.Superuser.Username, creds.Superuser.Password))

	// Create admin role
	sb.WriteString("-- Admin role (can assume all other roles)\n")
	sb.WriteString(fmt.Sprintf(`DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '%s') THEN
        CREATE ROLE %s WITH LOGIN PASSWORD '%s';
    ELSE
        ALTER ROLE %s WITH PASSWORD '%s';
    END IF;
END
$$;

`, creds.Admin.Username, creds.Admin.Username, creds.Admin.Password,
		creds.Admin.Username, creds.Admin.Password))

	// Create job-specific roles
	for role, cred := range creds.Roles {
		def := getRoleDefinition(role)
		if def == nil {
			continue
		}

		sb.WriteString(fmt.Sprintf("-- %s\n", def.Description))
		sb.WriteString(fmt.Sprintf(`DO $$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '%s') THEN
        CREATE ROLE %s WITH LOGIN PASSWORD '%s' NOINHERIT NOCREATEDB NOCREATEROLE;
    ELSE
        ALTER ROLE %s WITH PASSWORD '%s';
    END IF;
END
$$;

`, cred.Username, cred.Username, cred.Password, cred.Username, cred.Password))
	}

	// Grant role membership to admin
	sb.WriteString("-- Grant role membership to admin for SET ROLE\n")
	for role := range creds.Roles {
		sb.WriteString(fmt.Sprintf("GRANT %s TO %s;\n", role, creds.Admin.Username))
	}
	sb.WriteString("\n")

	return sb.String()
}

// GenerateGrantPermissionsSQL generates SQL to grant table permissions.
func (rm *RoleManager) GenerateGrantPermissionsSQL() string {
	var sb strings.Builder

	sb.WriteString("-- bibd Role Permissions\n")
	sb.WriteString("-- Generated by bibd - DO NOT EDIT MANUALLY\n\n")

	definitions := GetRoleDefinitions()

	for _, def := range definitions {
		if len(def.Tables) == 0 {
			continue
		}

		sb.WriteString(fmt.Sprintf("-- Permissions for %s\n", def.Name))
		for table, perms := range def.Tables {
			permStr := strings.Join(perms, ", ")
			sb.WriteString(fmt.Sprintf("GRANT %s ON %s TO %s;\n", permStr, table, def.Name))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// GenerateDropRolesSQL generates SQL to drop roles (for rotation cleanup).
func (rm *RoleManager) GenerateDropRolesSQL(creds *credentials.Credentials) string {
	var sb strings.Builder

	sb.WriteString("-- Drop old roles after rotation\n")

	// Revoke all permissions first
	for role := range creds.Roles {
		sb.WriteString(fmt.Sprintf("REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA public FROM %s;\n", role))
		sb.WriteString(fmt.Sprintf("REVOKE ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public FROM %s;\n", role))
	}
	sb.WriteString("\n")

	// Drop roles
	for role := range creds.Roles {
		sb.WriteString(fmt.Sprintf("DROP ROLE IF EXISTS %s;\n", role))
	}

	// Drop admin
	sb.WriteString(fmt.Sprintf("DROP ROLE IF EXISTS %s;\n", creds.Admin.Username))

	return sb.String()
}

// CreateRoles creates all PostgreSQL roles using the provided credentials.
func (rm *RoleManager) CreateRoles(ctx context.Context, conn *pgx.Conn, creds *credentials.Credentials) error {
	sql := rm.GenerateCreateRolesSQL(creds)

	_, err := conn.Exec(ctx, sql)
	if err != nil {
		return fmt.Errorf("failed to create roles: %w", err)
	}

	return nil
}

// GrantPermissions grants table permissions to all roles.
func (rm *RoleManager) GrantPermissions(ctx context.Context, conn *pgx.Conn) error {
	sql := rm.GenerateGrantPermissionsSQL()

	_, err := conn.Exec(ctx, sql)
	if err != nil {
		return fmt.Errorf("failed to grant permissions: %w", err)
	}

	return nil
}

// DropRoles drops roles (for rotation cleanup).
func (rm *RoleManager) DropRoles(ctx context.Context, conn *pgx.Conn, creds *credentials.Credentials) error {
	sql := rm.GenerateDropRolesSQL(creds)

	_, err := conn.Exec(ctx, sql)
	if err != nil {
		return fmt.Errorf("failed to drop roles: %w", err)
	}

	return nil
}

// VerifyRoleExists checks if a role exists in PostgreSQL.
func (rm *RoleManager) VerifyRoleExists(ctx context.Context, conn *pgx.Conn, roleName string) (bool, error) {
	var exists bool
	err := conn.QueryRow(ctx, "SELECT EXISTS(SELECT 1 FROM pg_roles WHERE rolname = $1)", roleName).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check role existence: %w", err)
	}
	return exists, nil
}

// VerifyRolePassword verifies that a role can authenticate with the given password.
func (rm *RoleManager) VerifyRolePassword(ctx context.Context, connString string, role storage.DBRole, password string) error {
	// Build connection string with role credentials
	testConnString := fmt.Sprintf("%s user=%s password=%s", connString, role, password)

	conn, err := pgx.Connect(ctx, testConnString)
	if err != nil {
		return fmt.Errorf("failed to connect as %s: %w", role, err)
	}
	defer conn.Close(ctx)

	// Verify role
	var currentRole string
	if err := conn.QueryRow(ctx, "SELECT current_user").Scan(&currentRole); err != nil {
		return fmt.Errorf("failed to verify role: %w", err)
	}

	if currentRole != string(role) {
		return fmt.Errorf("connected as %s, expected %s", currentRole, role)
	}

	return nil
}

// getRoleDefinition finds the definition for a role.
func getRoleDefinition(role storage.DBRole) *RoleDefinition {
	for _, def := range GetRoleDefinitions() {
		if def.Name == role {
			return &def
		}
	}
	return nil
}

// HardeningSQL returns SQL commands to harden role configurations.
func HardeningSQL() string {
	return `
-- Revoke public schema access
REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON ALL TABLES IN SCHEMA public FROM PUBLIC;
REVOKE ALL ON ALL SEQUENCES IN SCHEMA public FROM PUBLIC;
REVOKE ALL ON ALL FUNCTIONS IN SCHEMA public FROM PUBLIC;

-- Grant schema usage to bibd_admin only
GRANT USAGE ON SCHEMA public TO bibd_admin;
GRANT ALL ON ALL TABLES IN SCHEMA public TO bibd_admin;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO bibd_admin;

-- Ensure roles cannot modify themselves
ALTER ROLE bibd_scrape NOINHERIT NOCREATEDB NOCREATEROLE;
ALTER ROLE bibd_query NOINHERIT NOCREATEDB NOCREATEROLE;
ALTER ROLE bibd_transform NOINHERIT NOCREATEDB NOCREATEROLE;
ALTER ROLE bibd_audit NOINHERIT NOCREATEDB NOCREATEROLE;
ALTER ROLE bibd_readonly NOINHERIT NOCREATEDB NOCREATEROLE;

-- Set connection limits for job roles
ALTER ROLE bibd_scrape CONNECTION LIMIT 10;
ALTER ROLE bibd_query CONNECTION LIMIT 20;
ALTER ROLE bibd_transform CONNECTION LIMIT 10;
ALTER ROLE bibd_audit CONNECTION LIMIT 5;
ALTER ROLE bibd_readonly CONNECTION LIMIT 20;
`
}
