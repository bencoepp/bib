# Database Security & Hardening

This document describes the security architecture for bibd's PostgreSQL storage layer, covering credential management, role-based access, network isolation, configuration hardening, and encryption at rest.

## Overview

The bibd daemon implements a **Zero Trust Database Access** model where:

- The PostgreSQL instance is invisible to everything except bibd
- All credentials are generated, rotated, and never exposed
- Every database operation is audited
- Encryption protects data at rest and in transit

```
┌─────────────────────────────────────────────────────────────┐
│                    Security Boundary                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌──────────┐          ┌──────────────────────────────┐   │
│   │   bibd   │──mTLS───►│      Managed PostgreSQL       │   │
│   │          │          │                                │   │
│   │ ┌──────┐ │          │  • Unix socket (Linux)        │   │
│   │ │Creds │ │          │  • 127.0.0.1 only (TCP)       │   │
│   │ │Mgr   │ │          │  • No external access         │   │
│   │ └──────┘ │          │  • Role-based permissions     │   │
│   │          │          │  • Full audit logging         │   │
│   │ ┌──────┐ │          │  • Encryption at rest         │   │
│   │ │Role  │ │          │                                │   │
│   │ │Pool  │ │          └──────────────────────────────┘   │
│   │ └──────┘ │                                              │
│   └──────────┘                                              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

## Security Components

| Component | Package | Purpose |
|-----------|---------|---------|
| Credential Manager | `internal/storage/postgres/credentials` | Secure credential generation, encryption, and rotation |
| Role-Aware Pool | `internal/storage/postgres/pool` | Per-transaction role switching with SET LOCAL ROLE |
| Network Manager | `internal/storage/postgres/lifecycle` | Network isolation and security configuration |
| Config Generator | `internal/storage/postgres/lifecycle` | PostgreSQL hardening configuration |
| Encryption Manager | `internal/storage/postgres/encryption` | Encryption at rest with multiple methods |

---

## Credential Management

### Credential Generation

All PostgreSQL credentials are generated by bibd at initialization:

- **Password Length**: 64 characters (hex-encoded from 32 bytes of cryptographic randomness)
- **Character Set**: Hexadecimal (0-9, a-f) for maximum compatibility
- **Entropy**: 256 bits of entropy per password

```go
// Passwords are generated using crypto/rand
password, err := generatePassword(64)  // Returns 64-char hex string
```

### Encryption Methods

Credentials are encrypted before storage using one of three methods:

| Method | Algorithm | Key Derivation | Use Case |
|--------|-----------|----------------|----------|
| `x25519` | XSalsa20-Poly1305 (NaCl) | Ed25519 → X25519 conversion | Standard, well-audited |
| `hkdf` | AES-256-GCM | HKDF-SHA256 | FIPS-compatible environments |
| `hybrid` | Both methods | Both | Maximum compatibility (default) |

The encryption key is derived from the node's Ed25519 identity key, ensuring:
- Only the node that generated the credentials can decrypt them
- No plaintext passwords ever touch disk
- Key derivation is deterministic and reproducible

### Credential Storage

Encrypted credentials are stored at:
```
<config_dir>/secrets/db.enc
```

The file format includes:
- Version number for forward compatibility
- Encryption method identifier
- Encrypted JSON payload containing all role credentials

### Credential Rotation

Zero-downtime rotation follows this sequence:

```
┌─────────────────────────────────────────────────────────────┐
│                 Credential Rotation Flow                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Generate new credentials (Version N+1)                   │
│  2. Create new PostgreSQL roles with new passwords           │
│  3. Mark old credentials as "retiring" (still valid)         │
│  4. Update connection pool to use new credentials            │
│  5. Wait for grace period (default: 5 minutes)               │
│  6. Verify no connections using old credentials              │
│  7. Drop old PostgreSQL roles                                │
│  8. Mark old credentials as "expired" in storage             │
│  9. Audit log the rotation event                             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Dual Credential Sets**: During the grace period, both old and new credentials are valid, enabling zero-downtime rotation.

### Configuration

```yaml
credentials:
  # Encryption method: x25519, hkdf, or hybrid (default)
  encryption_method: "hybrid"
  
  # How often to rotate credentials
  rotation_interval: 168h  # 7 days
  
  # Grace period during rotation (old creds still valid)
  rotation_grace_period: 5m
  
  # Password length (minimum 32, recommended 64)
  password_length: 64
  
  # Custom storage path (optional)
  encrypted_path: ""  # Defaults to <config_dir>/secrets/db.enc
```

---

## Role-Based Database Access

### Database Roles

bibd creates six PostgreSQL roles with minimal permissions:

| Role | Purpose | Permissions |
|------|---------|-------------|
| `bibd_admin` | Connection pool role | Can SET ROLE to all others |
| `bibd_scrape` | Data ingestion jobs | INSERT on datasets, chunks; SELECT on topics |
| `bibd_query` | Read operations | SELECT on datasets, chunks, topics, jobs, nodes |
| `bibd_transform` | Data transformation | SELECT, INSERT, UPDATE on datasets, chunks |
| `bibd_audit` | Audit logging | INSERT, SELECT on audit_log |
| `bibd_readonly` | Cache/proxy operations | SELECT on all tables |

### Role Hierarchy

```
                    bibd_admin
                        │
        ┌───────┬───────┼───────┬───────┬───────┐
        ▼       ▼       ▼       ▼       ▼       ▼
    scrape   query  transform  audit  readonly
```

The `bibd_admin` role has GRANT membership to all other roles, enabling `SET ROLE` within transactions.

### Per-Transaction Role Switching

The Role-Aware Pool uses `SET LOCAL ROLE` for each transaction:

```go
// Acquire connection with specific role
conn, err := pool.AcquireWithRole(ctx, storage.RoleScrape)
defer conn.Release()

// All operations in this transaction use bibd_scrape permissions
conn.Exec(ctx, "INSERT INTO datasets ...")

// Role automatically resets on commit/rollback
conn.Commit(ctx)
```

This provides:
- **Isolation**: Each transaction has minimal required permissions
- **Auditability**: Role is logged with every operation
- **Efficiency**: Single connection pool serves all roles

### Role Selection via OperationContext

Roles are selected based on the `OperationContext`:

```go
// Create operation context with role
opCtx := storage.NewOperationContext(storage.RoleScrape, "p2p-sync")
ctx := storage.WithOperationContext(ctx, opCtx)

// Pool automatically uses the role from context
pool.Execute(ctx, func(tx pgx.Tx) error {
    // Operations run as bibd_scrape
    return nil
})
```

### Role Permission Matrix

| Table | scrape | query | transform | audit | readonly |
|-------|--------|-------|-----------|-------|----------|
| datasets | INSERT | SELECT | SELECT, INSERT, UPDATE | - | SELECT |
| chunks | INSERT | SELECT | SELECT, INSERT, UPDATE | - | SELECT |
| topics | SELECT | SELECT | SELECT | - | SELECT |
| jobs | - | SELECT | - | - | SELECT |
| nodes | - | SELECT | - | - | SELECT |
| audit_log | - | - | - | INSERT, SELECT | SELECT |

---

## Network Isolation

### Platform-Specific Security

| Platform | Connection Method | Security Level |
|----------|------------------|----------------|
| Linux | Unix socket | Maximum |
| macOS | TCP + mTLS (127.0.0.1) | High |
| Windows | TCP + mTLS (127.0.0.1) | High |
| Kubernetes | Pod network + NetworkPolicy | Maximum |

### Unix Socket Mode (Linux)

When using Unix sockets:
- PostgreSQL listens only on a Unix socket
- No TCP port is exposed
- Socket permissions restrict access to bibd process
- No network attack surface

```yaml
network:
  use_unix_socket: true
```

### TCP Mode (macOS/Windows)

When Unix sockets aren't available:
- PostgreSQL binds to `127.0.0.1` only
- mTLS required for all connections
- Client certificate verification mandatory
- TLS 1.3 enforced

```yaml
network:
  use_unix_socket: false
  bind_address: "127.0.0.1"
security:
  require_client_cert: true
```

### Docker Network Isolation

bibd creates an isolated Docker network:

```bash
docker network create \
  --internal \  # No external connectivity
  --driver bridge \
  --opt com.docker.network.bridge.enable_ip_masquerade=false \
  bibd-internal-<node-id>
```

Features:
- `--internal` flag prevents external connectivity
- IP masquerading disabled
- Only bibd container can access PostgreSQL
- No published ports

### Kubernetes Network Isolation

bibd creates a NetworkPolicy:

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: bibd-postgres-isolation
spec:
  podSelector:
    matchLabels:
      app: bibd-postgres
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: bibd
      ports:
        - protocol: TCP
          port: 5432
  egress: []  # No egress allowed
```

---

## PostgreSQL Hardening

### Configuration Generation

bibd generates hardened PostgreSQL configuration files:

| File | Purpose |
|------|---------|
| `postgresql.conf` | Server configuration |
| `pg_hba.conf` | Host-based authentication |
| `initdb.d/*.sql` | Initialization scripts |

### postgresql.conf Hardening

```ini
# Connection Security
listen_addresses = '*'  # Inside container; access controlled by port binding
port = 5432
max_connections = 100

# SSL/TLS (TLS 1.3 enforced)
ssl = on
ssl_min_protocol_version = 'TLSv1.3'
ssl_prefer_server_ciphers = on
ssl_ciphers = 'HIGH:!aNULL:!MD5:!3DES:!RC4'

# Authentication
password_encryption = scram-sha-256

# Audit Logging
log_statement = 'all'
log_connections = on
log_disconnections = on
log_duration = on
log_line_prefix = '%t [%p]: user=%u,db=%d,app=%a,client=%h '

# Security
row_security = on
```

### pg_hba.conf Hardening

```
# Local connections - SCRAM only
local   all   all                         scram-sha-256

# SSL with client certificate verification
hostssl all   all   127.0.0.1/32          scram-sha-256 clientcert=verify-full
hostssl all   all   ::1/128               scram-sha-256 clientcert=verify-full

# Reject everything else
host    all   all   0.0.0.0/0             reject
host    all   all   ::/0                  reject
```

### Initialization Scripts

Scripts run in order on first database creation:

| Script | Purpose |
|--------|---------|
| `00-extensions.sql` | Enable pg_stat_statements, pgcrypto, uuid-ossp |
| `01-roles.sql` | Create database roles with passwords |
| `02-schema.sql` | Create tables (placeholder for migrations) |
| `03-audit.sql` | Create audit_log table with append-only trigger |
| `04-hardening.sql` | Revoke PUBLIC permissions, set role limits |

### Client Certificate Authentication

```yaml
security:
  require_client_cert: true
  allow_client_cert_fallback: false  # No password-only auth
```

When enabled:
- bibd presents a client certificate for all connections
- Certificate CN must match allowed list
- Connection rejected if certificate validation fails

---

## Encryption at Rest

### Encryption Methods

bibd supports three encryption-at-rest methods:

| Method | Description | Platform | Use Case |
|--------|-------------|----------|----------|
| `luks` | Full disk encryption | Linux only | Maximum security |
| `tde` | PostgreSQL TDE | All | Transparent encryption |
| `application` | Field-level encryption | All | Selective encryption |
| `hybrid` | LUKS + Application | Linux | Defense in depth |

### Application-Level Encryption

Encrypts specific database fields before storage:

```yaml
encryption_at_rest:
  enabled: true
  method: "application"
  application:
    algorithm: "aes-256-gcm"
    encrypted_fields:
      - table: datasets
        columns: [content, metadata]
      - table: jobs
        columns: [parameters, result]
      - table: nodes
        columns: [metadata]
```

Features:
- AES-256-GCM authenticated encryption
- 12-byte random nonce per encryption
- Transparent to application code via FieldEncryptor
- Key derived from node identity

### LUKS Encryption (Linux)

Creates an encrypted volume for PostgreSQL data:

```yaml
encryption_at_rest:
  enabled: true
  method: "luks"
  luks:
    volume_size: "50GB"
    cipher: "aes-xts-plain64"
    key_size: 512
    hash_algorithm: "sha512"
```

Features:
- Full disk encryption via dm-crypt
- LUKS2 format with modern defaults
- Key derived from node identity
- Automatic mount/unmount on startup/shutdown

### Key Recovery with Shamir's Secret Sharing

For disaster recovery, encryption keys can be split using Shamir's Secret Sharing:

```yaml
encryption_at_rest:
  recovery:
    method: "shamir"
    shamir:
      total_shares: 5    # Generate 5 shares
      threshold: 3       # Need 3 to recover
      shareholder_ids:
        - "admin-1"
        - "admin-2"
        - "admin-3"
        - "backup-1"
        - "backup-2"
```

Recovery process:
1. Generate shares during initial setup
2. Distribute shares to trusted parties
3. Collect threshold shares for recovery
4. Reconstruct master key
5. Derive encryption keys from master

---

## Security Configuration

### Complete Example

```yaml
# Storage security configuration
database:
  backend: postgres
  postgres:
    managed: true
    
# Credential management
credentials:
  encryption_method: "hybrid"
  rotation_interval: 168h
  rotation_grace_period: 5m
  password_length: 64

# Encryption at rest
encryption_at_rest:
  enabled: true
  method: "application"
  application:
    algorithm: "aes-256-gcm"
    encrypted_fields:
      - table: datasets
        columns: [content, metadata]
  recovery:
    method: "shamir"
    shamir:
      total_shares: 5
      threshold: 3

# Security behavior
security:
  fallback_mode: "warn"           # strict, warn, permissive
  minimum_level: "moderate"       # maximum, high, moderate, reduced
  log_security_report: true
  require_client_cert: true
  allow_client_cert_fallback: false
```

### Security Levels

| Level | Description |
|-------|-------------|
| `maximum` | All security requirements met |
| `high` | Minor fallbacks (e.g., TCP instead of Unix socket) |
| `moderate` | Significant fallbacks (e.g., optional client certs) |
| `reduced` | Major fallbacks with warnings |

### Fallback Modes

| Mode | Behavior |
|------|----------|
| `strict` | Fail if any security requirement cannot be met |
| `warn` | Fall back with warnings (default) |
| `permissive` | Fall back silently |

---

## Security Report

On startup, bibd generates a security report:

```
╔══════════════════════════════════════════════════════════════╗
║                    Security Report                            ║
╠══════════════════════════════════════════════════════════════╣
║  Security Level: HIGH                                         ║
║                                                               ║
║  ✓ Credentials encrypted with hybrid method                  ║
║  ✓ Role-based access enabled (6 roles)                       ║
║  ✓ Client certificate authentication required                ║
║  ✓ TLS 1.3 enforced                                          ║
║  ✓ Application-level encryption enabled                      ║
║                                                               ║
║  ⚠ Using TCP instead of Unix socket (macOS limitation)       ║
║                                                               ║
║  Recommendations:                                             ║
║  • Consider deploying on Linux for Unix socket support        ║
║  • Enable LUKS encryption for defense in depth               ║
╚══════════════════════════════════════════════════════════════╝
```

---

## Audit Logging

All database operations are logged to the `audit_log` table:

| Field | Description |
|-------|-------------|
| `timestamp` | UTC timestamp with microsecond precision |
| `node_id` | Node that performed the operation |
| `job_id` | Associated job (if applicable) |
| `operation_id` | Unique operation identifier |
| `role_used` | Database role used |
| `action` | SELECT, INSERT, UPDATE, DELETE, DDL |
| `table_name` | Affected table |
| `rows_affected` | Number of rows affected |
| `duration_ms` | Operation duration |
| `source_component` | Which bibd component initiated |

The audit log is:
- **Append-only**: UPDATE and DELETE are blocked by trigger
- **Hash-chained**: Each entry includes hash of previous entry
- **Tamper-evident**: Chain breaks indicate tampering

---

## Best Practices

### Credential Security

1. **Never log credentials** - All logging redacts password fields
2. **Rotate regularly** - Default 7-day rotation interval
3. **Use hybrid encryption** - Provides forward compatibility
4. **Backup identity key** - Required for credential decryption

### Network Security

1. **Use Unix sockets on Linux** - Eliminates network attack surface
2. **Require client certificates** - Mutual TLS authentication
3. **Use isolated networks** - Docker internal networks or NetworkPolicy
4. **Never expose PostgreSQL port** - No published ports

### Access Control

1. **Use minimal roles** - Each operation uses least-privilege role
2. **Audit everything** - Enable comprehensive audit logging
3. **Review audit logs** - Monitor for suspicious patterns
4. **Rotate on compromise** - Trigger immediate credential rotation

---

## See Also

- [Storage Lifecycle Management](storage-lifecycle.md) - Container lifecycle
- [Configuration Guide](configuration.md) - Complete configuration reference
- [Clustering](clustering.md) - High-availability security considerations
- [Phase 2.3 Implementation Outline](phase-2.3-implementation-outline.md) - Technical details

